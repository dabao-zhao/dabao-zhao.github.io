<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 赵大宝的博客</title>
    <link>https://dabao-zhao.github.io/posts/</link>
    <description>Recent content in Posts on 赵大宝的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 09 Aug 2023 11:20:37 +0800</lastBuildDate><atom:link href="https://dabao-zhao.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>共识Raft：如何保证多机房数据的一致性</title>
      <link>https://dabao-zhao.github.io/posts/%E5%85%B1%E8%AF%86raft%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%A4%9A%E6%9C%BA%E6%88%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Wed, 09 Aug 2023 11:20:37 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/%E5%85%B1%E8%AF%86raft%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%A4%9A%E6%9C%BA%E6%88%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>答：基于 Raft 协议的分布式数据服务
raft 算法的动画展示
主要讲 Raft 的原理，后面找一个教程</description>
    </item>
    
    <item>
      <title>同城双活：如何实现机房之间的数据同步</title>
      <link>https://dabao-zhao.github.io/posts/%E5%90%8C%E5%9F%8E%E5%8F%8C%E6%B4%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%BA%E6%88%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Wed, 09 Aug 2023 10:58:10 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/%E5%90%8C%E5%9F%8E%E5%8F%8C%E6%B4%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%BA%E6%88%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</guid>
      <description>答：otter
后面再找一个 otter 的教程吧
常见的网络延迟参考 指一次 RTT 请求
同机房服务器：0.1 ms 同城服务器（100 公里以内）：1ms 北京到上海：38ms 北京到广州：53ms </description>
    </item>
    
    <item>
      <title>Token：如何降低用户身份鉴权的流量压力？</title>
      <link>https://dabao-zhao.github.io/posts/token%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83%E7%9A%84%E6%B5%81%E9%87%8F%E5%8E%8B%E5%8A%9B/</link>
      <pubDate>Tue, 08 Aug 2023 17:21:24 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/token%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83%E7%9A%84%E6%B5%81%E9%87%8F%E5%8E%8B%E5%8A%9B/</guid>
      <description>答：用 JWT
后面再找一个 JWT 的教程吧</description>
    </item>
    
    <item>
      <title>缓存一致：读多写少时，如何解决数据更新缓存不同步</title>
      <link>https://dabao-zhao.github.io/posts/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E6%97%B6%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E4%B8%8D%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 08 Aug 2023 15:22:18 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E6%97%B6%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E4%B8%8D%E5%90%8C%E6%AD%A5/</guid>
      <description>主要讲临时缓存和长期缓存，还有如何保障缓存数据的一致性
临时缓存和长期缓存 这里的临时缓存是指 TTL 比较短的缓存，长期缓存指 TTL 比较长的缓存而不是常驻的缓存
缓存更新办法 一般情况下简单数据可以在更新的时候清理缓存，等下次读取时刷新缓存，防止并发修改导致临时数据进入缓存。
复杂数据的更新可以使用 Maxwell 和 Canal 对 MySQL 的更新进行监控，这样变更信息会推送到 Kafka，然后脚本就可以进行消费去更新缓存
还介绍了版本号更新缓存和脚本遍历更新缓存，个人认为用处不大
缓存穿透问题 文里这块长期缓存和缓存穿透放一块了，其实容易让人认为长期缓存解决了缓存穿透的问题，实际上两者的关系不大。
百度百科对缓存穿透的解释是：缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。
临时缓存 + 长期热缓存的实现 // 尝试从缓存中直接获取用户信息 userinfo, err := Redis.Get(&amp;#34;user_info_9527&amp;#34;) if err != nil { return nil, err } //缓存命中找到，直接返回用户信息 if userinfo != nil { return userinfo, nil } //set 检测当前是否是热数据 //之所以没有使用Bloom Filter是因为有概率碰撞不准 //如果key数量超过千个，建议还是用Bloom Filter //这个判断也可以放在业务逻辑代码中，用配置同步做 isHotKey, err := Redis.SISMEMBER(&amp;#34;hot_key&amp;#34;, &amp;#34;user_info_9527&amp;#34;) if err != nil { return nil, err } //如果是热key if isHotKey { //没有找到就认为数据不存在 //可能是被删除了 return &amp;#34;&amp;#34;, nil } //没有命中缓存，并且没被标注是热点，被认为是临时缓存，那么从数据库中获取 //设置更新锁set user_info_9527_lock nx ex 5 //防止多个线程同时并发查询数据库导致数据库压力过大 lock, err := Redis.</description>
    </item>
    
    <item>
      <title>结构梳理：大并发下，你的数据库表可能成为性能隐患</title>
      <link>https://dabao-zhao.github.io/posts/%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86%E5%A4%A7%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%8F%AF%E8%83%BD%E6%88%90%E4%B8%BA%E6%80%A7%E8%83%BD%E9%9A%90%E6%82%A3/</link>
      <pubDate>Tue, 08 Aug 2023 14:12:36 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86%E5%A4%A7%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%8F%AF%E8%83%BD%E6%88%90%E4%B8%BA%E6%80%A7%E8%83%BD%E9%9A%90%E6%82%A3/</guid>
      <description>主要以用户中心为例，讲解如何对读多写少的系统进行高并发优化。
将数据分为了四种类型：数据实体表，辅助查询表，实体关系表，历史数据表。然后根据不同类型讲述了不同的缓存策略。
数据实体表 每行数据代表一个实体，会存在一个唯一 ID。 需要根据业务需要对表进行精简，只保留所需字段，其他字段可以纵向拆分到辅助查询表。 数据小了之后，能减少 B+Tree 的层次，查询和传输也会更快。 对于这个表来说，一般会使用 前缀_ID 作为 key 进行缓存。对于一些组合条件或者对数据会做计算的一般会采用定期更新缓存的办法或者单独分出一个从库。
辅助查询表 目的是拆分出使用频率不高的字段。这里主要是提醒要定期对数据进行整理核对来保障数据的同步和完整。
实体关系表 三种关系：1:n、n:1、m:n
尽量减少 m:n 出现的可能性，如果出现要额外用一个关系表来维护关联关系。关系表在高并发系统中一般会降低一致性 要求来满足高并发的情况。主要可能会出现多级依赖。
历史数据表 一般不会去做缓存，数据量大而且增长量也大
判断是否适合缓存的核心思路 能够通过 ID 快速匹配的实体，以及通过关系快速查询的数据，适合放在长期缓存当中 通过组合条件筛选统计的数据，也可以放到临时缓存，但是更新有延迟 数据增长量大或者跟设计初衷不一样的表数据，这种不适合、也不建议去做做缓存 总结 核心就是要对数据进行归类，然后再根据归类做对应的处理</description>
    </item>
    
    <item>
      <title>Linux 下安装和升级 Go</title>
      <link>https://dabao-zhao.github.io/posts/linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%87%E7%BA%A7go/</link>
      <pubDate>Tue, 08 Aug 2023 09:56:13 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%87%E7%BA%A7go/</guid>
      <description>安装 wget https://golang.google.cn/dl/go1.20.7.linux-amd64.tar.gz rm -rf /usr/local/go tar -C /usr/local -xzf go1.20.7.linux-amd64.tar.gz 打开 ~/.bashrc 并输入
export GOROOT=/usr/local/go export GOPATH=$HOME/gowork export GOBIN=$GOPATH/bin export PATH=$GOPATH:$GOBIN:$GOROOT/bin:$PATH 保存并关闭文件，输入以下命令以使更改生效
source ~/.bashrc 升级 操作与安装一致</description>
    </item>
    
  </channel>
</rss>
