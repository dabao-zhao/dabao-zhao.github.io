<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 赵大宝的博客</title>
    <link>https://dabao-zhao.github.io/posts/</link>
    <description>Recent content in Posts on 赵大宝的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 10 Aug 2023 17:10:18 +0800</lastBuildDate><atom:link href="https://dabao-zhao.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>领域拆分：如何合理地拆分系统</title>
      <link>https://dabao-zhao.github.io/posts/%E9%A2%86%E5%9F%9F%E6%8B%86%E5%88%86%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%9C%B0%E6%8B%86%E5%88%86%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 10 Aug 2023 17:10:18 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/%E9%A2%86%E5%9F%9F%E6%8B%86%E5%88%86%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%9C%B0%E6%8B%86%E5%88%86%E7%B3%BB%E7%BB%9F/</guid>
      <description>以供货协商流程为例讲述了如何拆分系统。
首先进行流程分析，要多和产品、研发团队沟通，以确定主要流程的数据走向和系统数据的依赖关系没有问题。 然后以一个数据实体不能承载太多职能为原则，将承担太多职能的部分进行拆分。 然后再分析系统的核心是否和当前系统实现的一致，如果不一致需要对模块进行拆分。 然后根据角色和流程梳理后的结果，按角色和其所需要的动作整理出新的流程图。 总体来讲，主要是根据流程、角色和关键元素做为切入点，然后将不同流程划分出不同阶段来归类分析，根据不同阶段拆分出不同的模块，然后再和产品和研发论证可行性。
上面主要讲了大体上应该怎么拆，下面主要讲细节上该怎么入手。
一般来说，系统功能从表拆分比较容易，因为业务流程基本都会围绕实体表运转，并关联多个实体进行交互。主要的拆分依据是：
数据实体职能只做最核心的一件事 业务流程归类按涉及实体进行归类，看能否分为多个阶段 由数据依赖交叉的频率决定是否把模块拆分，如果交互频繁可以合并 然后就是抽象的处理，越是底层的服务，越要注意抽象，主要为了减少变更，避免影响其他服务，因为很难确认底层的变更对上游系统的影响范围。
几个常见的抽象思路：
被动抽象法 如果两个或多个服务使用同一个业务逻辑，就把这个业务逻辑抽象成公共服务。适合代码量不大、维护人员很少、处于探索阶段的系统。
同层级之间的模块是禁止相互调用的。如果调用了，就需要将两个服务抽象成公共服务，让上层对两个服务进行聚合，目的是为了让系统结构从上到下是一个倒置的树形， 保证不会出现引用交叉循环的情况
动态辅助表 适用于规模稍微大一点的团队或系统。
如果一个表被多个开发组使用，而不同的业务特性也不同，可以在主表内存储 type，然后再根据 type 去对应不同的辅助表。例如：普通商品保存在表 order 和表 order_product_extra 中，定制类商品保存在 order_customize_extra 中。
强制标准接口 底层服务只做标准的服务，业务的个性部分都由业务自己完成。算是比较常见的做法。
总结 先从上到下做业务流程梳理，将流程归类聚合；然后从不同的领域聚合中找出交互所需主要实体，根据流程中主要实体之间的数据依赖程度决定是否拆分（从下到上看）； 把不同的实体和动作拆分成多个模块后，再根据业务流程归类，划分出最终的模块（最终汇总）。
极客时间的课，总结往往特别精华……</description>
    </item>
    
    <item>
      <title>Raft一致性算法论文中文翻译</title>
      <link>https://dabao-zhao.github.io/posts/raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E8%AE%BA%E6%96%87%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Thu, 10 Aug 2023 16:36:39 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E8%AE%BA%E6%96%87%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/</guid>
      <description>对 https://github.com/maemual/raft-zh_cn 的一个副本，防止丢失
寻找一种易于理解的一致性算法（扩展版） 寻找一种易于理解的一致性算法（扩展版） 摘要 1 介绍 2 复制状态机 3 Paxos 算法的问题 4 为了可理解性的设计 5 Raft 一致性算法 5.1 Raft 基础 5.2 领导人选举 5.3 日志复制 5.4 安全性 5.4.1 选举限制 5.4.2 提交之前任期内的日志条目 5.4.3 安全性论证 5.5 跟随者和候选人崩溃 5.6 时间和可用性 6 集群成员变化 7 日志压缩 8 客户端交互 9 算法实现和评估 9.1 可理解性 9.2 正确性 9.3 性能 10 相关工作 11 结论 12 感谢 参考 摘要 Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。一项用户研究的结果表明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。</description>
    </item>
    
    <item>
      <title>共识Raft：如何保证多机房数据的一致性</title>
      <link>https://dabao-zhao.github.io/posts/%E5%85%B1%E8%AF%86raft%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%A4%9A%E6%9C%BA%E6%88%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Wed, 09 Aug 2023 11:20:37 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/%E5%85%B1%E8%AF%86raft%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%A4%9A%E6%9C%BA%E6%88%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>答：基于 Raft 协议的分布式数据服务
参考资料 raft 算法的动画展示 官网 中文论文 </description>
    </item>
    
    <item>
      <title>同城双活：如何实现机房之间的数据同步</title>
      <link>https://dabao-zhao.github.io/posts/%E5%90%8C%E5%9F%8E%E5%8F%8C%E6%B4%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%BA%E6%88%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Wed, 09 Aug 2023 10:58:10 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/%E5%90%8C%E5%9F%8E%E5%8F%8C%E6%B4%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%BA%E6%88%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</guid>
      <description>答：otter
后面再找一个 otter 的教程吧
常见的网络延迟参考 指一次 RTT 请求
同机房服务器：0.1 ms 同城服务器（100 公里以内）：1ms 北京到上海：38ms 北京到广州：53ms </description>
    </item>
    
    <item>
      <title>Token：如何降低用户身份鉴权的流量压力？</title>
      <link>https://dabao-zhao.github.io/posts/token%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83%E7%9A%84%E6%B5%81%E9%87%8F%E5%8E%8B%E5%8A%9B/</link>
      <pubDate>Tue, 08 Aug 2023 17:21:24 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/token%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83%E7%9A%84%E6%B5%81%E9%87%8F%E5%8E%8B%E5%8A%9B/</guid>
      <description>答：用 JWT
后面再找一个 JWT 的教程吧</description>
    </item>
    
    <item>
      <title>缓存一致：读多写少时，如何解决数据更新缓存不同步</title>
      <link>https://dabao-zhao.github.io/posts/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E6%97%B6%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E4%B8%8D%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 08 Aug 2023 15:22:18 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E6%97%B6%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E4%B8%8D%E5%90%8C%E6%AD%A5/</guid>
      <description>主要讲临时缓存和长期缓存，还有如何保障缓存数据的一致性
临时缓存和长期缓存 这里的临时缓存是指 TTL 比较短的缓存，长期缓存指 TTL 比较长的缓存而不是常驻的缓存
缓存更新办法 一般情况下简单数据可以在更新的时候清理缓存，等下次读取时刷新缓存，防止并发修改导致临时数据进入缓存。
复杂数据的更新可以使用 Maxwell 和 Canal 对 MySQL 的更新进行监控，这样变更信息会推送到 Kafka，然后脚本就可以进行消费去更新缓存
还介绍了版本号更新缓存和脚本遍历更新缓存，个人认为用处不大
缓存穿透问题 文里这块长期缓存和缓存穿透放一块了，其实容易让人认为长期缓存解决了缓存穿透的问题，实际上两者的关系不大。
百度百科对缓存穿透的解释是：缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。
临时缓存 + 长期热缓存的实现 // 尝试从缓存中直接获取用户信息 userinfo, err := Redis.Get(&amp;#34;user_info_9527&amp;#34;) if err != nil { return nil, err } //缓存命中找到，直接返回用户信息 if userinfo != nil { return userinfo, nil } //set 检测当前是否是热数据 //之所以没有使用Bloom Filter是因为有概率碰撞不准 //如果key数量超过千个，建议还是用Bloom Filter //这个判断也可以放在业务逻辑代码中，用配置同步做 isHotKey, err := Redis.SISMEMBER(&amp;#34;hot_key&amp;#34;, &amp;#34;user_info_9527&amp;#34;) if err != nil { return nil, err } //如果是热key if isHotKey { //没有找到就认为数据不存在 //可能是被删除了 return &amp;#34;&amp;#34;, nil } //没有命中缓存，并且没被标注是热点，被认为是临时缓存，那么从数据库中获取 //设置更新锁set user_info_9527_lock nx ex 5 //防止多个线程同时并发查询数据库导致数据库压力过大 lock, err := Redis.</description>
    </item>
    
    <item>
      <title>结构梳理：大并发下，你的数据库表可能成为性能隐患</title>
      <link>https://dabao-zhao.github.io/posts/%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86%E5%A4%A7%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%8F%AF%E8%83%BD%E6%88%90%E4%B8%BA%E6%80%A7%E8%83%BD%E9%9A%90%E6%82%A3/</link>
      <pubDate>Tue, 08 Aug 2023 14:12:36 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86%E5%A4%A7%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%8F%AF%E8%83%BD%E6%88%90%E4%B8%BA%E6%80%A7%E8%83%BD%E9%9A%90%E6%82%A3/</guid>
      <description>主要以用户中心为例，讲解如何对读多写少的系统进行高并发优化。
将数据分为了四种类型：数据实体表，辅助查询表，实体关系表，历史数据表。然后根据不同类型讲述了不同的缓存策略。
数据实体表 每行数据代表一个实体，会存在一个唯一 ID。 需要根据业务需要对表进行精简，只保留所需字段，其他字段可以纵向拆分到辅助查询表。 数据小了之后，能减少 B+Tree 的层次，查询和传输也会更快。 对于这个表来说，一般会使用 前缀_ID 作为 key 进行缓存。对于一些组合条件或者对数据会做计算的一般会采用定期更新缓存的办法或者单独分出一个从库。
辅助查询表 目的是拆分出使用频率不高的字段。这里主要是提醒要定期对数据进行整理核对来保障数据的同步和完整。
实体关系表 三种关系：1:n、n:1、m:n
尽量减少 m:n 出现的可能性，如果出现要额外用一个关系表来维护关联关系。关系表在高并发系统中一般会降低一致性 要求来满足高并发的情况。主要可能会出现多级依赖。
历史数据表 一般不会去做缓存，数据量大而且增长量也大
判断是否适合缓存的核心思路 能够通过 ID 快速匹配的实体，以及通过关系快速查询的数据，适合放在长期缓存当中 通过组合条件筛选统计的数据，也可以放到临时缓存，但是更新有延迟 数据增长量大或者跟设计初衷不一样的表数据，这种不适合、也不建议去做做缓存 总结 核心就是要对数据进行归类，然后再根据归类做对应的处理</description>
    </item>
    
    <item>
      <title>Linux 下安装和升级 Go</title>
      <link>https://dabao-zhao.github.io/posts/linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%87%E7%BA%A7go/</link>
      <pubDate>Tue, 08 Aug 2023 09:56:13 +0800</pubDate>
      
      <guid>https://dabao-zhao.github.io/posts/linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%87%E7%BA%A7go/</guid>
      <description>安装 wget https://golang.google.cn/dl/go1.20.7.linux-amd64.tar.gz rm -rf /usr/local/go tar -C /usr/local -xzf go1.20.7.linux-amd64.tar.gz 打开 ~/.bashrc 并输入
export GOROOT=/usr/local/go export GOPATH=$HOME/gowork export GOBIN=$GOPATH/bin export PATH=$GOPATH:$GOBIN:$GOROOT/bin:$PATH 保存并关闭文件，输入以下命令以使更改生效
source ~/.bashrc 升级 操作与安装一致</description>
    </item>
    
  </channel>
</rss>
